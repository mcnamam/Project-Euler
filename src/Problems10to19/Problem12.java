package Problems10to19;


import java.util.ArrayList;
import java.util.List;

/**
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
 * The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6        2:4
 10: 1,2,5,10      2:4
 15: 1,3,5,15      2:4
 21: 1,3,7,21      2:4
 28: 1,2,4,7,14,28 3:6

 (Adding in 8th, 9th, 10th to demonstrate that nth term does not necessarily have more
  factors than (n-1)th term)
 36: 1,2,3,4,6,9,12,18,36 4:9
 45: 1,3,5,9,15,45  3:6
 55: 1,5,11,55
 66: 1,2,3,6,11,22,33,66
 72: 1,2,3,4,6,9,12,18,36,72 5:10   2 3 5 7 11 13 17 19 23 29 31 37 41

 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
 */

public class Problem12 {

    private static long START_TIME = System.currentTimeMillis();
    private static final int MIN_NUM_DIVISORS = 500;

    // to identify divisors of a given number, let's precompute a bunch of prime numbers
    // which we can use to quickly find divisors
    private static boolean[] primes = new boolean[Integer.MAX_VALUE/20000];
    private static List<Integer> PRIMES_LIST = new ArrayList<>();
    static {
        // initialize primes to be all true
        for (int i = 2; i < primes.length; i++) {
            primes[i] = true;
        }
        /**
         *   Use a Sieve of Eratosthenes approach to find prime numbers starting from 2
         *   https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
         *
         *   Numbers are marked as prime/non-prime in the primes boolean array (index in the array
         *   corresponds to the number itself).
         */
        // start at 2
        int lastPrimeFound = 2;

        while(true) {
            // mark all multiples of the most recently discovered prime to be non-prime
            for (int j = 2 * lastPrimeFound; j < primes.length; j += lastPrimeFound) {
                primes[j] = false;
            }

            final int currentPrime = lastPrimeFound;
            PRIMES_LIST.add(currentPrime);
            // discover the next prime by starting just past the most recently discovered prime and
            // iterating until you find an index in primes array that has not been marked as non-prime
            for (int j = lastPrimeFound + 1; j < primes.length; j++) {
                if (primes[j]) {
                    lastPrimeFound = j;
                    break;
                }
            }

            // check if any more primes were found before reaching the end of the primes array
            if (lastPrimeFound == currentPrime) {
                break;
            }

        }
    }

    /**
     * The nth triangle number is equal to the sum of 1 + 2 + ... + n-1 + n = n*(n+1)/2
     * We could use a brute-force approach of iterating up from 1 to INTEGER.MAX,
     * calculate the triangle number, and calculate the number of divisors until we find the
     * first number with 501+ divisors
     */
    public static void main(String[] args) {
        int currentTriangleNumber = 0;
        for (int n=1;true; n++) {
            currentTriangleNumber +=n;
            final int numDivisors = findNumDivisors(currentTriangleNumber);
            if (numDivisors > MIN_NUM_DIVISORS) {
                break;
            }
        }

        System.out.println("The first triangle number to have more than " + MIN_NUM_DIVISORS + " divisors is " + currentTriangleNumber);
        System.out.println("Finished in " + (System.currentTimeMillis() - START_TIME) + " ms");
    }

    /**
     * Alternate, potentially optimized implementation:
     *
     * The number of divisors D is equal to the product of 1 + the power of each prime factor
     *  in a number's prime factorization e.g. 28 = 2^2 * 7^1 = (2+1) * (1+1) = 6 divisors
     * From this formula, every prime factor added to a prime factorization doubles the
     *  number of divisors.  2^9 = 512 > 500 so we could just pick the first 9 primes,
     *  multiply them together, and come up with a number that has 2^9=512 divisors.
     *
     * To get from a given number to the nearest triangle number, we'll use the formula
     *  X = nth triangle number = n * (n+1) / 2 => 2 * X = n * (n+1) ~= n^2
     * So take the square root of the number and round it up or down to establish the nearest
     *  triangle number.
     *
     * We can calculate the smallest possible number to have D divisors from this upper starting point.
     * This is guaranteed to be <= the smallest triangle number to have D divisors.
     * Start by removing the largest prime factorization term, which should halve the number of divisors.
     * Next, find the largest prime factor that when its power decreased by 1 then doubled is smaller than the just-removed large term.
     * Repeat this process until you can find no more such terms
     *
     * Here are real numbers corresponding to this problem to demonstrate, all of which produce numbers with 512 divisors:
     *  2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 = 223092870
     *  2 * 3^3 * 5 * 7 * 11 * 13 * 17 * 19 = 87297210 (3^2 < 23)
     *  2^3 * 3^3 * 5 * 7 * 11 * 13 * 17 = 18378360 (2^2 < 19)
     *  2^7 * 3^3 * 5 * 7 * 11 * 13 = 17297280 (2^4 < 17)
     *
     * Thus we can say with high confidence that the first triangle number is in the range [17297280, 223092870]
     *
     */
//    public static void main(String[] args) {
//        final int roundedUpLogBaseTwoOfNumDivisors = (int) Math.ceil(Math.log10(MIN_NUM_DIVISORS) / Math.log10(2));
//        int upperStartingPoint = 1;
//        for (int i = 0; i < roundedUpLogBaseTwoOfNumDivisors; i++) {
//            upperStartingPoint *= PRIMES_LIST.get(i);
//        }
//        final int roundedUpUpperSquareRoot = (int) Math.ceil(Math.sqrt(upperStartingPoint*2));
//        int upperEndingN = roundedUpUpperSquareRoot;
//        int lowerStartingPoint = upperStartingPoint;
//
//        int[] primeFactorPowers = new int[roundedUpLogBaseTwoOfNumDivisors];
//        for (int i=0; i<primeFactorPowers.length; i++) {
//            primeFactorPowers[i] = 1;
//        }
//        int indexOfLargestRemainingPrimeFactor = roundedUpLogBaseTwoOfNumDivisors - 1;
//        int largestRemainingPrimeFactor = PRIMES_LIST.get(indexOfLargestRemainingPrimeFactor);
//        boolean canReduceLowerStartingPoint = true;
//
//        while (canReduceLowerStartingPoint) {
//            canReduceLowerStartingPoint = false;
//            int indexOfLargestPrimeFactorThatCanHavePowerIncreased = -1;
//            int largestPrimeFactorThatCanHavePowerIncreased = 0;
//            for (int i=0; i<indexOfLargestRemainingPrimeFactor; i++) {
//                int primeFactor = PRIMES_LIST.get(i);
//                int primeFactorPower = primeFactorPowers[i]*2;
//                if ((int) Math.pow(primeFactor, primeFactorPower) < largestRemainingPrimeFactor) {
//                    largestPrimeFactorThatCanHavePowerIncreased = primeFactor;
//                    canReduceLowerStartingPoint = true;
//                    indexOfLargestPrimeFactorThatCanHavePowerIncreased = i;
//                } else {
//                    break;
//                }
//            }
//
//            if (canReduceLowerStartingPoint) {
//                lowerStartingPoint = lowerStartingPoint / largestRemainingPrimeFactor;
//                indexOfLargestRemainingPrimeFactor--;
//                largestRemainingPrimeFactor = PRIMES_LIST.get(indexOfLargestRemainingPrimeFactor);
//
//                primeFactorPowers[indexOfLargestPrimeFactorThatCanHavePowerIncreased] *= 2;
//                final int power = primeFactorPowers[indexOfLargestPrimeFactorThatCanHavePowerIncreased];
//                lowerStartingPoint = lowerStartingPoint * (int) Math.pow(largestPrimeFactorThatCanHavePowerIncreased, power);
//            }
//        }
//
//        int lowerStartingN = (int) Math.floor(Math.sqrt(lowerStartingPoint));
//        int currentTriangleNumber = (lowerStartingN * (lowerStartingN + 1)) / 2;
//        for (int n=lowerStartingN+1; n < upperEndingN; n++) {
//            currentTriangleNumber += n;
//            final int numDivisors = findNumDivisors(currentTriangleNumber);
//            if (numDivisors > MIN_NUM_DIVISORS) {
//                break;
//            }
//        }
//
//        System.out.println("The first triangle number to have more than " + MIN_NUM_DIVISORS + " divisors is " + currentTriangleNumber);
//        System.out.println("Finished in " + (System.currentTimeMillis() - START_TIME) + " ms");
//    }

    /**
     * This function returns the number of divisors for a given number n
     * It iterates through our precomputed prime number set to find prime numbers that are divisors of n
     */
    public static int findNumDivisors(int n) {
        int productOfPrimeDivisors = 1;

        for (int primeNum : PRIMES_LIST) {
            if (primeNum >= n) {
                break;
            }
            if (n % primeNum == 0) {
                int powerOfPrimeNum = 1;
                int factor = n / primeNum;
                while (factor % primeNum == 0) {
                    powerOfPrimeNum++;
                    factor /= primeNum;
                }
                productOfPrimeDivisors *= powerOfPrimeNum+1;
            }
        }

        return productOfPrimeDivisors;
    }
}
